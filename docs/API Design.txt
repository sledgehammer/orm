
 API Design
------------

// Bestaande rij aanpassen (rij met id=1 uit de customer tabel)
$c1 = new Customer(1); 
$c1->lastname = 'Achternaam';
$c1->save();

Dual Mode
----------

Omdat "Late Static Binding" pas in 5.3 zit kan ik daar (nog) geen gebruik van maken.
Dan zou je "$c1 = Customer::find(1);" kunnen doen. (Zonder dat je deze statische functie in alle subclasses moet zetten)
En omdat ik niet per model een container en instantie class/bestand wil worden deze in 1 class gecombineerd.
Geen CustomerTable->find(1) returns Customer1


= static mode (aka class/daemon/server/container mode)=

$customers = new Customer();

$c1 = $customers->find(1);

$c = $customers->create();

$customers->delete(1);

$collection = $customers->all();


= instance mode =

$customer = new Customer(1);

$customer->save();

$customer->delete();

$customer->getChanges();

echo $customer->lastname;

$customer->lastname = "Achternaam";


De functies en eigenschappen in in de ene modes toegankelijk zijn, zijn in de andere modus niet beschikbaar.
"delete" is de enige functie in in beide modus toegankelijk is, maar de aanroep is anders.
Ookal zou het technisch kunnen om de static functies ook werken in instance mode, wordt dit niet toegestaan.
Als een een instance meegeeft in een parameter, wil je niet dat er ook andere instances aangepast kunnen worden.
Na de __construct() blijft een object in static of instance mode.

 Exceptions
------------
De Record is trigger-happy als het gaat om Exceptions.
Hierdoor zijn er geen if-blokken's nodig bij de operaties van de Record class.

Bijvoorbeeld:
  find() returns  Record of een Exception als er 0 of meer dan 1 rij wordt gevonden.


 Restricties
--------------

Aan de Record->find() en Record->all() kun je restricties meegeven.
Een van de doelen van de Record class is het voorkomen van SQL injecties.
Hierdoor is er geen optie om een alleen een WHERE string mee te geven aan de find()/all() functies. (Zoals dat bij Ruby on Rails's ActiveRecord wel mag)

De Record->find() heeft 3 verschillende type restricties: primary_key, array en sprintf.

  Array restrictie
  --------------
  find(array('name' => 'Bob')) wordt: WHERE name = "Bob"
  find(array('name' => 'Bob', 'address' => 'Dorpsstraat 12"')) wordt: WHERE name = "Bob" AND address = "Dorpsstraat 12\""

  sprintf restrictie
  -------------------
  find('name = ?', 'Bob') wordt: WHERE name = "Bob"
  find('name = ? AND age >= ?', 'Bob', 18) wordt: WHERE name = "Bob" AND age >= 18

  De sprintf methode is de enige methode die gevoelig is voor SQL injectie, maar de extra parameters worden worden geescaped.

  Primary key
  ------------
  find(1) wordt: WHERE id = "1"
  find('name = "Bob"') wordt: WHERE id = "name = \"Bob\""

Voor sprintf methode is er minimaal 1 variable verplicht. (Om SQL injsect van de Primary key methode te voorkomen)
Als een tabel meer dan 1 kolom heef als primairy key, kan de array restrictie gebruikt worden om de rij te openen.

(Record)Collections
--------------------
Met de $customer->all() wordt een collectie customers opvraagd.
Als je geen parameters meegeeft worden en er geen (extra) restricties toevoegd en krijg je een collectie met alle record.

Een recordCollection werkt met behulp van een SQL class, die je via chainable functies kunt aanpassen.

$collection = $customer->all()->where('age >= 18')->orderBy('age', 'DESC');
foreach ($collection as $c) {
	echo $->name . ' - ' . $c->age;
}

 Relaties
----------

= hasOne =

 Kolommen die eindigen op "_id" worden "gemarkeerd" als foreignkey en zijn niet verplicht als class-eigenschap.
 Deze relaties maken kunnen geconfigureerd worden in de "hasOne" array.
 hasOne['klant'] = array('record' => new Klant());

 Lezen:
   echo $bestelling->klant->lastname

 Instellen:
	$klant = new Klant(2);
	$bestelling->klant = $klant;
    $bestelling->save();
  of
    $bestelling->klant_id = 2;
	$bestelling->save();

  De hasOne werkt prima met 1-1, 1-0 en n-1 relaties.

= hasMany =

 Voor de 1-n en n-m relaties is er de hasMany eigenschap. Deze ondersteund de volgende 3 usecases

 UseCase 1 = Klant met bestellingen
  Hier gaat het om 1-n relatie. 1 klant met 0-n bestellingen.

  Lezen:
    $total = 0
    foreach($klant->bestellingen as $bestelling) {
      $total += $bestelling->total;
    }
    echo $total;

  Bewerken:
    $klant->bestellingen[123]->korting = 99;
    $klant->save();

  Toevoegen
	$klant->bestellingen[] = $bestelling;
    $klant->save();
   of
	$klant->bestellingen->add($bestelling);
    $klant->save();
   of
    $klant->bestellingen[25] = new Bestelling(25);
    $klant->save();

  Waarbij elke $bestelling een record is.


UseCase 3
  De table_values structuur:
  De "table_values" table heeft de kolommen "table_id", "name", "value"
  waar table een foreign key is naar "table.id" en de primary_kley is een combo van "table_id" en "name"

Deze gegevens wil vraag je op :
  $record = new SimpleRecord('table', 1, *config*)
  dump($table->values);
Geeft:
  array(
	'name1' => 'value1'
  )

De gegevens bijwerken:
  $record->values['name1'] = 'valueY';
  $record->save();



 Een hasMany is een RecordRelation object
  Re


Internal modes
---------------
STATIC
UPDATE 
INSERT
DELETED 


<!-- DEPRECATED DOCS:
Met all() vraag je een "collection" object op met alle records; of alle records die voldoen aan de meegegeven "restricties"

De Array methode:
    $customer->all(array('name' => 'Bob'));
    Wordt: WHERE name = "Bob".
    Maar in deze situatie wordt de waarde geescaped.  (Via Database->quote()) en is daardoor beter bestand tegen sql injecties.

De sprintf methode:
    $customer->all('name = ? AND address = ?', 'Bob', 'Dorpsstraat 123');
    Wordt: WHERE name = "Bob" AND address = "Dorpsstraat 123"


De SQL string methode:
  $customer->all('name LIKE "%B"')
  Wordt:  WHERE name LIKE "%B"
  Deze methode is gevoelig voor SQL injecties


Onderstaande aanroepen werken niet. (By Design)
  $record->find('name LIKE "%B"'); en
  $record->find(array('operator' => 'AND', 'name = "Bob"', 'address = "Dorpsstraat 123"'));
-->