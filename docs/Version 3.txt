
ORM Duties/Goals
-----------------
 * Retrieving data from a database/datasource and inject that data into an object.
   - List
   - Read
   - Create/Update
 * Protect againt SQL injection
 * OOP aproach to database records.


Looking back on Version 2
--------------------------
The good:
+ protection against sql injection 
+ Lazy relations
+ new RecordClass($id);
+ columns as properties (a object is a row in the db)
+ relations as properties
+ Only save/update the changes
+ config for the customer in the customer class (no boilerplate mapper classes of xml configurations)
+ A record (instance) object cant modify other records
+ Column/property validation (no silent dataloss)
+ Quick & dirty with SimpleRecord
+ Strict: No first() method, find() returns 1 object or an exception

Shady:
+ Dual mode, a alternative/difficult concept.
+ Not POCO
+ AutoCompletion for the static mode
+ No support for greedy relations

Bad:
+ Cryptic errors on incorrect configurations.
+ Low discoverabily of functionality / Difficult to configure.


New technology available for ORM v3 
------------------------
 - Closures ($this support in 5.4)
 - Late static binding
 - Traits/Mixins (support in PHP5.4?)



The silver bullet
------------------

The class should determines the structure. 
  $customer->address->city that maps to the 'city' column in the 'customers' table.

Full support for IDE autocompletion

Only one instance per row.
  $c1 = new Customer(1);
  $c2 = new Customer(1); // $c2 becomes a reference to $c1;

ORM can save and retrieves POCO (Plain Old Class Objects)

No performance penalty

Autosaving?

Don't depend on SQL, but allow it.
  Alternative datasources can't support sql.
  Allowing SQL for the datasources that support is powerfull (great featureset with great performance). 
  

Supports multiple sources. 
  $player->tweets (player from db, tweets from the twitter API)



Concept descriptions
---------

POCO (Plain Old Class Objects)
  the save() / delete() methods dont make sense on all (record) objects.
  Also no inheritance of interface required.

  No direct connection between datasource and object?
  aka support for multiple database connections for the same class.



Thoughts on LINQ / Entity
-------------------------

linq is nice, entity has migration issues (citation needed)



Thoughts and pitfalls on php 5.3 (lsb)
---------------------------------

limited IDE autocompletion?


Implementation ideas
------
= Improved mapping =
 xpath notation for mapping notation:
 column "city" to property "address/city" translates to $x->address->city; // or "address.city"? or "address->city"?
 // is 'address' a array, stdClass, ArrayObject or custom class? 
 // Getting autocompletion to work: @var AddresStruct public $address

= Repository =
Loading and Saving logic outside the Record object.
Aka a Repository link instead of an db_link
Repository extracts configuration from the record class but allows you to redefine those values a.k.a use a test database.

= Fake classes =
Generate fake phpClasses in the tmp/ folder to enable autocompletion for dynamic methods like Repository->findCustomer(1) 
/**
 * @return /AutoCompletionHelper/Repository 
function getRepository() {
}


= (Auto)Generated RepositoryClass =
Also generate the function body and use this class the next run.



Collection API (Table/static-mode)
-------------------

To automate controllers like the JsonCrudController
$t = $repo->getCustomerCollection(); //new Record/Table('ClassName', $repo);
// CRUD
$t->find($id);
$t->findAll($criteria);
$t->add($o); //insert
$t->update($o);
$t->delete($id);
$t->deleteAll($criteria);
// Filtering/List
$rs = $t->all();
$rs->where('x = 2');
foreach($rs as $record) {}


Repository API
---------------
$repository = getRepository('default');
$customer = $repository->getCustomer($id);
$customer = $repository->findCustomer($criteria);
$repository->saveCustomer($customer);
$table = $repository->getCustomersTable();
$repository->saveAll()?


Record API
-----------.
@property $_recordConfig => array('repository' => 'default', 'table' => 'customer', 'hasMany' => array(), 'belongsTo' => array())
or
@return RecordConfig
Record->getRecordConfig()


= abstract GenericRecord =
Has conveniance methods

new GenericRecord(id)
GenericRecord::find()
GenericRecord::findAll()
GenericRecord->save()
GenericRecord->delete()
GenericRecord::deleteAll()
(private)GenriceRecord->_state = 'NEW'|'EXISTING'|'DELETED'
GenericRecord::$repository;




SimpleRecord
----------------
SimpleRecord inspects the repository/database and generates properties and _config.


Issues
-------
injecting values into private properties (with data from the db)
  Inject via an "SH/Record/PrivateProperties" interface? setPrivateProperties($values)
    Caller should be checked/validated?

injecting lazy-loaded relations.


Rejected ideas
---------------
Autogenerator repositories based on database connection.
'default' => new DbRepo(getDatabase('default'));
*Because* we can use one Repository instance to handle multiple database connections/schema's